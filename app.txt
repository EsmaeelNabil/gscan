=== engine/chromedp.go ===
package engine

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	"github.com/chromedp/chromedp"
)

func LogStep(step string) chromedp.Action {
	return chromedp.ActionFunc(func(ctx context.Context) error {
		fmt.Println(step)
		return nil
	})
}

func GetContext() (context.Context, context.CancelFunc) {
	// Get the user's home directory.
	home, err := os.UserHomeDir()
	if err != nil {
		log.Fatal(err)
	}

	// Define the profile directory inside the home folder.
	profileDir := filepath.Join(home, ".gscan_profile")
	// Check if the directory exists.
	if _, err := os.Stat(profileDir); os.IsNotExist(err) {
		log.Println("You might need to login first\nUse : gscan -login")
	}
	// creating chrome context
	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Headless,
		chromedp.NoSandbox,
		chromedp.UserDataDir(profileDir),
		chromedp.Flag("enable-automation", false),
		chromedp.NoFirstRun,
		chromedp.NoDefaultBrowserCheck,
		chromedp.Flag("disable-extensions", true),
		chromedp.Flag("start-maximized", true),
	)

	allocCtx, cancelAllocator := chromedp.NewExecAllocator(context.Background(), opts...)

	return allocCtx, cancelAllocator
}

func GetLoginTasks(username, password, otp string) chromedp.Tasks {
	return chromedp.Tasks{
		chromedp.Navigate("https://github.com/login"),
		chromedp.WaitVisible(`input[name="login"]`),
		chromedp.SendKeys(`input[name="login"]`, username),
		chromedp.WaitVisible(`input[name="password"]`),
		chromedp.SendKeys(`input[name="password"]`, password),
		chromedp.WaitVisible(`input[name="commit"][value="Sign in"]`),
		chromedp.Click(`input[name="commit"][value="Sign in"]`),

		// Wait for the 2FA recovery link and click it
		chromedp.WaitVisible(`a[data-test-selector="totp-app-link"]`),
		chromedp.Click(`a[data-test-selector="totp-app-link"]`),
		// Wait for the recovery code input field
		chromedp.WaitVisible(`input[name="app_otp"]`),
		LogStep("- OTP Visible ✅"),
		chromedp.SendKeys(`input[name="app_otp"]`, otp),
		LogStep("- OTP Done ✅"),
		chromedp.Sleep(1 * time.Second),
	}
}

func GetSearchTasks(query, searchType string, page int) chromedp.Tasks {
	return chromedp.Tasks{
		LogStep("- Searching for : " + query),
		chromedp.Navigate(fmt.Sprintf("https://github.com/search?q=%s&type=%s&p=%d", query, searchType, page)),
	}
}

=== gemini/client.go ===
package gemini

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

func Summarize(content string) {
	ctx := context.Background()
	apiKey, ok := os.LookupEnv("GEMINI_API_KEY")
	if !ok {
		log.Fatalln("Environment variable GEMINI_API_KEY not set")
	}

	client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		log.Fatalf("Error creating client: %v", err)
	}
	defer client.Close()

	model := client.GenerativeModel("gemini-2.0-flash-thinking-exp-01-21")

	model.SetTemperature(1)
	model.SetTopK(64)
	model.SetTopP(0.95)
	model.SetMaxOutputTokens(8192)
	model.ResponseMIMEType = "text/plain"

	session := model.StartChat()
	session.History = []*genai.Content{}

	resp, err := session.SendMessage(ctx, genai.Text(content))
	if err != nil {
		log.Fatalf("Error sending message: %v", err)
	}

	for _, part := range resp.Candidates[0].Content.Parts {
		fmt.Printf("%v\n", part)
	}
}

=== github/github.go ===
package github

import (
	"context"
	"fmt"
	"gscan/engine"
	"gscan/otp"
	"log"
	"os"

	"github.com/chromedp/chromedp"
)

func GithubSearch(ctx context.Context, query, searchType string, page int) (string, error) {
	searchTasks := engine.GetSearchTasks(query, searchType, page)

	var htmlContent string

	appendedScreenShotTasks := append(
		searchTasks,
		chromedp.Tasks{
			chromedp.OuterHTML("html", &htmlContent),
		},
	)

	if err := chromedp.Run(ctx, appendedScreenShotTasks); err != nil {
		fmt.Println(err)
		return "", err
	}

	return htmlContent, nil
}

func Login(isVerbose bool, ctx context.Context) {
	username := os.Getenv("GITHUB_USER")
	password := os.Getenv("GITHUB_PASS")
	TwoFASecretKey := os.Getenv("TOTP_SECRET")

	if len(TwoFASecretKey) == 0 {
		log.Fatalf("Make sure you added TOTP_SECRET to your env variables")
		os.Exit(1)
	}

	if len(username) == 0 || len(password) == 0 {
		fmt.Println("Make sure you added GITHUB_USER and GITHUB_PASS to your env variables")
		os.Exit(1)
	}

	otp := otp.GenerateTotp(TwoFASecretKey)

	if isVerbose {
		fmt.Println("- T-OTP: ", otp)
	}

	loginTasks := engine.GetLoginTasks(username, password, otp)

	if err := chromedp.Run(ctx, loginTasks); err != nil {
		fmt.Println(err)
		return
	}
}

=== go.mod ===
module gscan

go 1.24.0

require (
	github.com/chromedp/chromedp v0.12.1
	github.com/google/generative-ai-go v0.19.0
	github.com/pquerna/otp v1.4.0
	google.golang.org/api v0.222.0
)

require (
	cloud.google.com/go v0.115.0 // indirect
	cloud.google.com/go/ai v0.8.0 // indirect
	cloud.google.com/go/auth v0.14.1 // indirect
	cloud.google.com/go/auth/oauth2adapt v0.2.7 // indirect
	cloud.google.com/go/compute/metadata v0.6.0 // indirect
	cloud.google.com/go/longrunning v0.5.7 // indirect
	github.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc // indirect
	github.com/chromedp/cdproto v0.0.0-20250120090109-d38428e4d9c8 // indirect
	github.com/chromedp/sysutil v1.1.0 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/gobwas/httphead v0.1.0 // indirect
	github.com/gobwas/pool v0.2.1 // indirect
	github.com/gobwas/ws v1.4.0 // indirect
	github.com/google/s2a-go v0.1.9 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect
	github.com/googleapis/gax-go/v2 v2.14.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/mailru/easyjson v0.9.0 // indirect
	go.opentelemetry.io/auto/sdk v1.1.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.58.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.58.0 // indirect
	go.opentelemetry.io/otel v1.34.0 // indirect
	go.opentelemetry.io/otel/metric v1.34.0 // indirect
	go.opentelemetry.io/otel/trace v1.34.0 // indirect
	golang.org/x/crypto v0.33.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/oauth2 v0.26.0 // indirect
	golang.org/x/sync v0.11.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
	golang.org/x/time v0.10.0 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20241209162323-e6fa225c2576 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250212204824-5a70512c5d8b // indirect
	google.golang.org/grpc v1.70.0 // indirect
	google.golang.org/protobuf v1.36.5 // indirect
)

=== lib/utils.go ===
package lib

import (
	"fmt"
	"os"
	"time"
)

func BufferToFile(buffer []byte) error {
	err := os.WriteFile(fmt.Sprintf("screenshot_%d.png", time.Now().UnixMilli()), buffer, 0644)
	if err != nil {
		return err
	}

	fmt.Println("- Screenshot Saved Successfully ✅")
	return nil
}

=== main.go ===
package main

import (
	"flag"
	"fmt"
	"gscan/engine"
	"gscan/gemini"
	"gscan/github"
	"os"

	"github.com/chromedp/chromedp"
)

var prompt string = ""

func main() {
	query := flag.String("query", "", "Github Search Query")
	searchType := flag.String("type", "code", "Github Search Query type, code || repositories || issues || pullrequests || users || commits")
	count := flag.Int("count", 1, "Github Search Query Code Pages count, max 5")
	loginIsNeeded := false
	flag.BoolFunc("login", "Will Login and presist the user session of the engine for later usage", func(s string) error {
		loginIsNeeded = true
		return nil
	})
	isVerbose := false
	flag.BoolFunc("v", "verbose messages on each step", func(s string) error {
		isVerbose = true
		return nil
	})
	flag.Parse()

	allocCtx, cancelAllocator := engine.GetContext()
	defer cancelAllocator()
	browserContext, cancelBrowserContext := chromedp.NewContext(allocCtx)
	defer cancelBrowserContext()

	if loginIsNeeded {
		github.Login(isVerbose, browserContext)
		fmt.Println("Successfully Logged in ..")
		os.Exit(0)
	}

	if len(*query) > 0 {
		if *searchType == "code" {
			for page := 1; page <= *count; page++ {
				html, err := github.GithubSearch(browserContext, *query, *searchType, page)
				if err != nil {
					fmt.Println(err)
				}

				fmt.Println("Thinking ... ")
				gemini.Summarize(fmt.Sprintf("This Html source is the search result for a search query in github.com search, convert it into md format or a format that would be easially reradable in the unix terminals, the query was (%s) and the content is : %s", *query, html))
			}
		} else {

			html, err := github.GithubSearch(browserContext, *query, *searchType, 1)
			if err != nil {
				fmt.Println(err)
			}

			fmt.Println("Thinking ... ")
			gemini.Summarize(fmt.Sprintf(prompt, query, html))

		}
	}
}

=== otp/totp.go ===
package otp

import (
	"fmt"
	"time"

	"github.com/pquerna/otp/totp"
)

func GenerateTotp(secret string) string {
	otp, codeErr := totp.GenerateCode(secret, time.Now())

	if codeErr != nil {
		panic(codeErr)
	}
	fmt.Println("- T-OTP Code Generated ✅")
	return otp
}

